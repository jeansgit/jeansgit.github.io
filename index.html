<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Jean’s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="My blogs">
<meta property="og:type" content="website">
<meta property="og:title" content="Jean’s Blog">
<meta property="og:url" content="http://www.yi-diandian.com/index.html">
<meta property="og:site_name" content="Jean’s Blog">
<meta property="og:description" content="My blogs">
<meta property="article:author" content="Jean">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Jean’s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jean’s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">你真正是谁并不重要，重要的是你的所作所为。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.yi-diandian.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-ew" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/06/ew/" class="article-date">
  <time datetime="2020-04-06T02:28:14.252Z" itemprop="datePublished">2020-04-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/">渗透测试</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/06/ew/">ew使用教程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>192.168.98.110（有开端口映射）对应的外网ip 117.28.113.252</p>
<p>9301 对外监听的端口<br>ew_for_Win.exe -s rcsocks -l 1080 -e 9301</p>
<ul>
<li>1.改privoxy（192.168.98.110）的config.txt里8118为8119</li>
<li>2.运行privoxy.exe </li>
<li>3.ew_for_Win.exe -s rcsocks -l 1080 -e 9301（本机运行）</li>
<li>4.ew_for_Win.exe -s rssocks -d 117.28.113.252 -e 9301 （对方机子上运行）</li>
<li>5.浏览器设置代理192.168.98.110:8119 访问内网的网站 </li>
</ul>
<p>使用Privoxy将socks5代理转为http代理</p>
<p>socks5代理:    执行的端口是1080<br>Privoxy:    端口是8118</p>
<p>所以浏览器代理是192.168.98.110:8118</p>
<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><pre><code>EarthWorm是一款用于开启 SOCKS v5 代理服务的工具，基于标准 C 开发，可提供多平台间的转接通讯，用于复杂网络环境下的数据转发。
专有主页： http://rootkiter.com/EarthWorm/</code></pre><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><h2 id="普通网络环境"><a href="#普通网络环境" class="headerlink" title="普通网络环境"></a>普通网络环境</h2><ol>
<li><p>目标网络边界存在公网IP且可任意开监听端口：</p>
<pre><code>  +---------+     +-------------------+  
  |HackTools| -&gt;&gt; | 8888-&gt;  1.1.1.1   |
  +---------+     +-------------------+

a)./ew -s ssocksd -l 8888
        // 在 1.1.1.1 主机上通过这个命令开启 8888 端口的 socks 代理
b) HackTools 可通过访问 1.1.1.1:8888 端口使用 1.1.1.1 主机提供的代理</code></pre></li>
<li><p>目标网络边界不存在公网 IP，需要通过反弹方式创建 socks 代理</p>
<pre><code>                        一台可控公网IP主机                  可控内网主机
  +---------+     +--------------------------+    |     +---------------+
  |HackTools| -&gt;&gt; | 1080 -&gt;  1.1.1.1 -&gt; 8888 |  防火墙  | &lt;--  2.2.2.2  |
  +---------+     +--------------------------+    |     +---------------+

a) ./ew -s rcsocks -l 1080 -e 8888
            // 在 1.1.1.1 的公网主机添加转接隧道，将 1080 收到的代理请求转交给反连 8888 端口的主机
b) ./ew -s rssocks -d 1.1.1.1 -e 8888          
            // 将目标网络的可控边界主机反向连接公网主机

c) HackTools 可通过访问 1.1.1.1:1080 端口使用 rssocks 主机提供的 socks5 代理服务</code></pre></li>
</ol>
<h2 id="对于二重网络环境："><a href="#对于二重网络环境：" class="headerlink" title="对于二重网络环境："></a>对于二重网络环境：</h2><ol>
<li><p>获得目标网络内两台主机 A、B 的权限，情况描述如下：</p>
<pre><code>A 主机：  存在公网 IP，且自由监听任意端口，无法访问特定资源
B 主机：  目标网络内部主机，可访问特定资源，但无法访问公网
A 主机可直连 B 主机

                        可控边界主机A             可访问指定资源的主机B
  +---------+     +-----------------------+      +-----------------+
  |HackTools| -&gt;&gt; | 1080 --&gt;  2.2.2.2 --&gt; | -&gt;&gt;  | 9999 -&gt; 2.2.2.3 |
  +---------+     +-----------------------+      +-----------------+

a)  ./ew -s ssocksd -l 9999
        // 在 2.2.2.3 主机上利用 ssocksd 方式启动 9999 端口的 socks 代理
b)  ./ew -s lcx_tran -l 1080 -f 2.2.2.3 -g 9999 
        // 将 1080 端口收到的 socks 代理请求转交给 2.2.2.3 的主机。
c)  HackTools 可通过访问 2.2.2.2:1080 来使用 2.2.2.3 主机提供的 socks5 代理。</code></pre></li>
<li><p>获得目标网络内两台主机 A、B 的权限，情况描述如下：</p>
<pre><code>A 主机：  目标网络的边界主机，无公网 IP，无法访问特定资源。
B 主机：  目标网络内部主机，可访问特定资源，却无法回连公网。

A 主机可直连 B 主机
                      一台可控公网IP主机                    可控内网主机A         可访问指定资源的主机B
  +---------+     +--------------------------+    |    +-----------------+      +-----------------+
  |HackTools| -&gt;&gt; | 1080 -&gt;  1.1.1.1 -&gt; 8888 |  防火墙  | &lt;--  2.2.2.2 --&gt; | -&gt;&gt; | 9999 -&gt; 2.2.2.3 |
  +---------+     +--------------------------+    |    +-----------------+      +-----------------+

a)  ./ew -s lcx_listen -l 1080 -e 8888
            // 在 1.1.1.1 公网主机添加转接隧道，将 1080 收到的代理请求
            // 转交给反连 8888 端口的主机
b)  ./ew -s ssocksd -l 9999
            // 在 2.2.2.3 主机上利用 ssocksd 方式启动 9999 端口的 socks 代理
c)  ./ew -s lcx_slave -d 1.1.1.1 -e 8888 -f 2.2.2.3 -g 9999
            // 在 2.2.2.2 上，通过工具的 lcx_slave 方式，打通1.1.1.1:8888 和 2.2.2.3:9999 之间的通讯隧道
d)  HackTools 可通过访问 1.1.1.1:1080 来使用 2.2.2.3 主机提供的 socks5 代理</code></pre></li>
</ol>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><pre><code>目前工具提供六种链路状态，可通过 -s 参数进行选定，分别为:

    ssocksd   rcsocks   rssocks   
    lcx_slave lcx_tran  lcx_listen

    其中 SOCKS5 服务的核心逻辑支持由 ssocksd 和 rssocks 提供，分别对应正向与反向socks代理。

    其余的 lcx 链路状态用于打通测试主机同 socks 服务器之间的通路。

lcx 类别管道：

    lcx_slave  该管道一侧通过反弹方式连接代理请求方，另一侧连接代理提供主机。
    lcx_tran   该管道，通过监听本地端口接收代理请求，并转交给代理提供主机。
    lcx_listen 该管道，通过监听本地端口接收数据，并将其转交给目标网络回连的代理提供主机。

    通过组合lcx类别管道的特性，可以实现多层内网环境下的渗透测试。

    下面是一个三级跳的本地测试例子。。。
    ./ew -s rcsocks -l 1080 -e 8888
    ./ew -s lcx_slave -d 127.0.0.1 -e 8888 -f 127.0.0.1 -g 9999
    ./ew -s lcx_listen -l 9999 -e 7777
    ./ew -s rssocks -d 127.0.0.1 -e 7777

    数据流向为   IE -&gt; 1080 -&gt; 8888 -&gt; 9999 -&gt; 7777 -&gt; rssocks </code></pre><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><ul>
<li>1.为了减少网络资源的消耗，程序中添加了超时机制，默认时间为10000毫秒（10秒），<br>   用户可以通过追加 -t 参数来调整这个值，单位为毫秒。在多级级联功能中，超时机制<br>   将以隧道中最短的时间为默认值。</li>
<li>2.单纯从设计原理上讲，多级级联的三种状态可以转发任意以TCP为基础的通讯服务，<br>   包括远程桌面／web服务 等。</li>
<li>3.产品包中的 ew_for_Arm32 在开发者已有平台下（android手机、小米路由器、树莓派） 测试无误。<br>   如果有其它异常环境请将对应详细细节反馈给作者，以便更新程序问题。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.yi-diandian.com/2020/04/06/ew/" data-id="ck8nv1ajo000egkh588x72i02" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ew/" rel="tag">ew</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BB%A3%E7%90%86/" rel="tag">代理</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-dasp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/06/dasp/" class="article-date">
  <time datetime="2020-04-06T02:28:14.247Z" itemprop="datePublished">2020-04-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/06/dasp/">DASP智能合约Top10漏洞</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>该项目是NCC集团的一项举措。这是一个开放的合作项目，致力于发现安全社区内的智能合约漏洞。</p>
<p>GitHub地址 <a href="https://github.com/CryptoServices/dasp" target="_blank" rel="noopener">https://github.com/CryptoServices/dasp</a></p>
<p>在了解智能合约Top10之前，我们简单说一下，OWASP Top10。<br>OWASP: Open Web Application Security Project</p>
<p>这个项目会公开十大web应用程序安全风险<br>2017年版下载地址<a href="http://www.owasp.org.cn/owasp-project/OWASPTop102017v1.3.pdf" target="_blank" rel="noopener">http://www.owasp.org.cn/owasp-project/OWASPTop102017v1.3.pdf</a></p>
<p>类似的，我们有了智能合约Top10漏洞。以下是国外原创，翻译过来的，翻译可能不准确，还请理解。</p>
<h1 id="1-重入"><a href="#1-重入" class="headerlink" title="1.重入"></a>1.重入</h1><p>也被称为或与空竞争，递归调用漏洞，未知调用等。</p>
<p>这种漏洞在很多时候被很多不同的人忽略：审阅者倾向于一次一个地审查函数，并且假定保护子例程的调用将安全并按预期运行。——–菲尔戴安</p>
<h2 id="重入攻击介绍"><a href="#重入攻击介绍" class="headerlink" title="重入攻击介绍"></a>重入攻击介绍</h2><p>重入攻击，可能是最着名的以太坊漏洞，</p>
<p>第一次被发现时，每个人都感到惊讶。</p>
<p>它在数百万美元的抢劫案中首次亮相，导致了以太坊的分叉。</p>
<p>当初始执行完成之前，外部合同调用被允许对调用合同进行新的调用时，就会发生重新进入。</p>
<p>对于函数来说，这意味着合同状态可能会在执行过程中因为调用不可信合同或使用具有外部地址的低级函数而发生变化。</p>
<p>损失：估计为350万ETH（当时约为5000万美元）</p>
<h2 id="攻击发现时间表"><a href="#攻击发现时间表" class="headerlink" title="攻击发现时间表"></a>攻击发现时间表</h2><p>2016/6/5—-Christian Reitwiessner发现了一个坚定的反模式<br><a href="https://blog.ethereum.org/2016/06/10/smart-contract-security/" target="_blank" rel="noopener">https://blog.ethereum.org/2016/06/10/smart-contract-security/</a></p>
<p>2016/6/9—-更多以太坊攻击：Race-To-Empty是真正的交易（vessenes.com）<br><a href="http://vessenes.com/more-ethereum-attacks-race-to-empty-is-the-real-deal/" target="_blank" rel="noopener">http://vessenes.com/more-ethereum-attacks-race-to-empty-is-the-real-deal/</a></p>
<p>2016/6/12—-在以太坊智能合约’递归调用’错误发现（blog.slock.it）之后，没有DAO资金面临风险。<br><a href="https://blog.slock.it/no-dao-funds-at-risk-following-the-ethereum-smart-contract-recursive-call-bug-discovery-29f482d348b" target="_blank" rel="noopener">https://blog.slock.it/no-dao-funds-at-risk-following-the-ethereum-smart-contract-recursive-call-bug-discovery-29f482d348b</a></p>
<p>2016/6/17—-我认为TheDAO现在正在流失（reddit.com）<br><a href="https://www.reddit.com/r/ethereum/comments/4oi2ta/i_think_thedao_is_getting_drained_right_now/" target="_blank" rel="noopener">https://www.reddit.com/r/ethereum/comments/4oi2ta/i_think_thedao_is_getting_drained_right_now/</a></p>
<p>2016/8/24—-DAO的历史和经验教训（blog.sock.it）<br><a href="https://blog.slock.it/the-history-of-the-dao-and-lessons-learned-d06740f8cfa5" target="_blank" rel="noopener">https://blog.slock.it/the-history-of-the-dao-and-lessons-learned-d06740f8cfa5</a></p>
<h3 id="真实世界影响"><a href="#真实世界影响" class="headerlink" title="真实世界影响"></a>真实世界影响</h3><p>DAO<br><a href="https://en.wikipedia.org/wiki/The_DAO_(organization)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/The_DAO_(organization)</a></p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>一个聪明的合约跟踪一些外部地址的平衡，并允许用户通过其公共资金检索withdraw()功能。<br>一个恶意的智能合约使用withdraw()函数检索其全部余额。<br>在更新恶意合约的余额之前，受害者合约执行call.value(amount)() 低级别函数将以太网发送给恶意合约。<br>该恶意合约有一个支付fallback()接受资金的功能，然后回调到受害者合约的withdraw()功能。<br>第二次执行会触发资金转移：请记住，恶意合约的余额尚未从首次提款中更新。结果， 恶意合约第二次成功退出了全部余额。<br>代码示例<br>以下函数包含易受重入攻击影响的函数。当低级别call()函数向msg.sender地址发送ether时，它变得易受攻击; 如果地址是智能合约，则付款将触发其备用功能以及剩余的交易gas：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function withdraw(uint _amount) &#123;</span><br><span class="line">	require(balances[msg.sender] &gt;&#x3D; _amount);</span><br><span class="line">	msg.sender.call.value(_amount)();</span><br><span class="line">	balances[msg.sender] -&#x3D; _amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h3><p>DAO智能合约<br><a href="https://etherscan.io/address/0xbb9bc244d798123fde783fcc1c72d3bb8c189413#code" target="_blank" rel="noopener">https://etherscan.io/address/0xbb9bc244d798123fde783fcc1c72d3bb8c189413#code</a></p>
<p>分析DAO的利用<br><a href="http://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/" target="_blank" rel="noopener">http://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/</a></p>
<p>简单的DAO代码示例<br><a href="http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao" target="_blank" rel="noopener">http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao</a></p>
<p>重入代码示例<br><a href="https://github.com/trailofbits/not-so-smart-contracts/tree/master/reentrancy" target="_blank" rel="noopener">https://github.com/trailofbits/not-so-smart-contracts/tree/master/reentrancy</a></p>
<p>有人试图利用我们的智能合约中的一个缺陷，盗取它的一切<br><a href="https://blog.citymayor.co/posts/how-someone-tried-to-exploit-a-flaw-in-our-smart-contract-and-steal-all-of-its-ether/" target="_blank" rel="noopener">https://blog.citymayor.co/posts/how-someone-tried-to-exploit-a-flaw-in-our-smart-contract-and-steal-all-of-its-ether/</a></p>
<h1 id="2-访问控制"><a href="#2-访问控制" class="headerlink" title="2.访问控制"></a>2.访问控制</h1><p>通过调用initWallet函数，可以将Parity Wallet库合约变为常规多sig钱包并成为它的所有者。</p>
<p>访问控制问题在所有程序中都很常见，而不仅仅是智能合约。</p>
<p>事实上，这是OWASP排名前10位的第5位。人们通常通过其公共或外部功能访问合约的功能。</p>
<p>尽管不安全的可视性设置会给攻击者直接访问合约的私有价值或逻辑的方式，但访问控制旁路有时更加微妙。</p>
<p>这些漏洞可能发生在合约使用已弃用tx.origin的验证调用者时，长时间处理大型授权逻辑require并delegatecall在代理库或代理合约中鲁莽使用。</p>
<p>损失：估计为150,000 ETH（当时约3000万美元）</p>
<p>真实世界影响<br>奇偶校验错误1<br><a href="http://paritytech.io/the-multi-sig-hack-a-postmortem/" target="_blank" rel="noopener">http://paritytech.io/the-multi-sig-hack-a-postmortem/</a></p>
<p>奇偶校验错误2<br><a href="http://paritytech.io/a-postmortem-on-the-parity-multi-sig-library-self-destruct/" target="_blank" rel="noopener">http://paritytech.io/a-postmortem-on-the-parity-multi-sig-library-self-destruct/</a></p>
<p>Rubixi<br><a href="https://blog.ethereum.org/2016/06/19/thinking-smart-contract-security/" target="_blank" rel="noopener">https://blog.ethereum.org/2016/06/19/thinking-smart-contract-security/</a></p>
<p>示例<br>一个聪明的合约指定它初始化它作为合约的地址。这是授予特殊特权的常见模式，例如提取合约能力。<br>不幸的是，初始化函数可以被任何人调用，即使它已经被调用。允许任何人成为合约者并获得资金。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>在下面的例子中，契约的初始化函数将函数的调用者设置为它的所有者。然而，逻辑与合约的构造函数分离，并且不记录它已经被调用的事实。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function initContract() public &#123;</span><br><span class="line">	owner &#x3D; msg.sender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Parity multi-sig钱包中，这个初始化函数与钱包本身分离并在“库”合约。用户需要通过调用库的函数来初始化自己的钱包delegateCall。不幸的是，在我们的例子中，函数没有检查钱包是否已经被初始化。更糟糕的是，由于图书馆是一个聪明的合约，任何人都可以自行初始化图书馆并要求销毁。</p>
<h3 id="其他资源-1"><a href="#其他资源-1" class="headerlink" title="其他资源"></a>其他资源</h3><p>修复Parity多信号钱包bug 1<br><a href="https://github.com/paritytech/parity/pull/6103/files" target="_blank" rel="noopener">https://github.com/paritytech/parity/pull/6103/files</a></p>
<p>奇偶校验安全警报2<br><a href="http://paritytech.io/security-alert-2/" target="_blank" rel="noopener">http://paritytech.io/security-alert-2/</a></p>
<p>在奇偶钱包multi-sig hack上<br><a href="https://blog.zeppelin.solutions/on-the-parity-wallet-multisig-hack-405a8c12e8f7" target="_blank" rel="noopener">https://blog.zeppelin.solutions/on-the-parity-wallet-multisig-hack-405a8c12e8f7</a></p>
<p>不受保护的功能<br><a href="https://github.com/trailofbits/not-so-smart-contracts/tree/master/unprotected_function" target="_blank" rel="noopener">https://github.com/trailofbits/not-so-smart-contracts/tree/master/unprotected_function</a></p>
<p>Rubixi的智能合约<br><a href="https://etherscan.io/address/0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code" target="_blank" rel="noopener">https://etherscan.io/address/0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code</a></p>
<h1 id="3-算数问题"><a href="#3-算数问题" class="headerlink" title="3.算数问题"></a>3.算数问题</h1><p>这个问题，我们之前的文章有提到，也就是比较经典的溢出。</p>
<p>也被称为整数溢出和整数下溢。</p>
<p>溢出情况会导致不正确的结果，特别是如果可能性未被预期，可能会影响程序的可靠性和安全性。——Jules Dourlens</p>
<p>溢出简介</p>
<p>整数溢出和下溢不是一类新的漏洞，但它们在智能合约中尤其危险</p>
<p>其中无符号整数很普遍，大多数开发人员习惯于简单int类型（通常是有符号整数）</p>
<p>如果发生溢出，许多良性代码路径成为盗窃或拒绝服务的载体。</p>
<h3 id="真实世界影响-1"><a href="#真实世界影响-1" class="headerlink" title="真实世界影响"></a>真实世界影响</h3><p>DAO<br><a href="http://blockchain.unica.it/projects/ethereum-survey/attacks.html" target="_blank" rel="noopener">http://blockchain.unica.it/projects/ethereum-survey/attacks.html</a></p>
<p>BatchOverflow（多个令牌）<br><a href="https://peckshield.com/2018/04/22/batchOverflow/" target="_blank" rel="noopener">https://peckshield.com/2018/04/22/batchOverflow/</a></p>
<p>ProxyOverflow（多个令牌）<br><a href="https://peckshield.com/2018/04/25/proxyOverflow/" target="_blank" rel="noopener">https://peckshield.com/2018/04/25/proxyOverflow/</a></p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>一个聪明的合约的withdraw()功能，您可以为您的余额仍是手术后积极检索，只要捐赠合约醚。</p>
<p>一个攻击者试图收回比他或她的当前余额多。</p>
<p>该withdraw()功能检查的结果总是正数，允许攻击者退出超过允许。</p>
<p>由此产生的余额下降，并成为比它应该更大的数量级。</p>
<h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><p>最直接的例子是一个不检查整数下溢的函数，允许您撤销无限量的标记：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function withdraw(uint _amount) &#123;</span><br><span class="line">	require(balances[msg.sender] - _amount &gt; 0);</span><br><span class="line">	msg.sender.transfer(_amount);</span><br><span class="line">	balances[msg.sender] -&#x3D; _amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个例子（在无益的Solidity编码竞赛期间被发现<a href="https://github.com/Arachnid/uscc/tree/master/submissions-2017/doughoyte）" target="_blank" rel="noopener">https://github.com/Arachnid/uscc/tree/master/submissions-2017/doughoyte）</a><br>是由于数组的长度由无符号整数表示的事实促成的错误的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function popArrayOfThings() &#123;</span><br><span class="line">	require(arrayOfThings.length &gt;&#x3D; 0);</span><br><span class="line">	arrayOfThings.length--; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三个例子是第一个例子的变体，其中两个无符号整数的算术结果是一个无符号整数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function votes(uint postId, uint upvote, uint downvotes) &#123;</span><br><span class="line">	if (upvote - downvote &lt; 0) &#123;</span><br><span class="line">		deletePost(postId)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四个示例提供了即将弃用的var关键字。由于var将自身改变为包含指定值所需的最小类型，因此它将成为uint8保持值0.如果循环的迭代次数超过255次，它将永远达不到该数字，并且在执行运行时停止出gas：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var i &#x3D; 0; i &lt; somethingLarge; i ++) &#123;</span><br><span class="line">	&#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他资源-2"><a href="#其他资源-2" class="headerlink" title="其他资源"></a>其他资源</h3><p>SafeMath防止溢出<br><a href="https://ethereumdev.io/safemath-protect-overflows/" target="_blank" rel="noopener">https://ethereumdev.io/safemath-protect-overflows/</a></p>
<h3 id="整数溢出代码示例"><a href="#整数溢出代码示例" class="headerlink" title="整数溢出代码示例"></a>整数溢出代码示例</h3><p><a href="https://github.com/trailofbits/not-so-smart-contracts/tree/master/integer_overflow" target="_blank" rel="noopener">https://github.com/trailofbits/not-so-smart-contracts/tree/master/integer_overflow</a></p>
<h1 id="4-未检查返回值的低级别调用"><a href="#4-未检查返回值的低级别调用" class="headerlink" title="4.未检查返回值的低级别调用"></a>4.未检查返回值的低级别调用</h1><p>也称为或与无声失败发送， 未经检查发送。</p>
<p>应尽可能避免使用低级别“呼叫”。如果返回值处理不当，它可能会导致意外的行为。—-Remix</p>
<p>其中的密实度的更深层次的特点是低级别的功能call()，callcode()，delegatecall()和send()。他们在计算错误方面的行为与其他Solidity函数完全不同，因为他们不会传播（或冒泡），并且不会导致当前执行的全部回复。相反，他们会返回一个布尔值设置为false，并且代码将继续运行。这可能会让开发人员感到意外，如果未检查到这种低级别调用的返回值，则可能导致失败打开和其他不想要的结果。请记住，发送可能会失败！</p>
<h3 id="真实世界影响-2"><a href="#真实世界影响-2" class="headerlink" title="真实世界影响"></a>真实世界影响</h3><p>以太之王—-<a href="https://www.kingoftheether.com/postmortem.html" target="_blank" rel="noopener">https://www.kingoftheether.com/postmortem.html</a><br>Etherpot—-<a href="https://www.dasp.co/" target="_blank" rel="noopener">https://www.dasp.co/</a></p>
<h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><p>下面的代码是一个当忘记检查返回值时会出错的例子send()。</p>
<p>如果调用用于将ether发送给不接受它们的智能合约（例如，因为它没有应付回退功能）</p>
<p>则EVM将用其替换其返回值false。</p>
<p>由于在我们的例子中没有检查返回值，因此函数对合约状态的更改不会被恢复，并且etherLeft变量最终会跟踪一个不正确的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function withdraw(uint256 _amount) public &#123;</span><br><span class="line">	require(balances[msg.sender] &gt;&#x3D; _amount);</span><br><span class="line">	balances[msg.sender] -&#x3D; _amount;</span><br><span class="line">	etherLeft -&#x3D; _amount;</span><br><span class="line">	msg.sender.send(_amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他资源-3"><a href="#其他资源-3" class="headerlink" title="其他资源"></a>其他资源</h3><p>未经检查的外部电话<br><a href="https://github.com/trailofbits/not-so-smart-contracts/tree/master/unchecked_external_call" target="_blank" rel="noopener">https://github.com/trailofbits/not-so-smart-contracts/tree/master/unchecked_external_call</a></p>
<p>扫描“未经检查 - 发送”错误的现场以太坊合约<br><a href="http://hackingdistributed.com/2016/06/16/scanning-live-ethereum-contracts-for-bugs/" target="_blank" rel="noopener">http://hackingdistributed.com/2016/06/16/scanning-live-ethereum-contracts-for-bugs/</a></p>
<h1 id="5-拒绝服务"><a href="#5-拒绝服务" class="headerlink" title="5.拒绝服务"></a>5.拒绝服务</h1><p>包括达到气量上限，意外抛出，意外杀死，访问控制违规</p>
<p>I accidentally killed it. ——–devops199 on the Parity multi-sig wallet</p>
<p>在以太坊的世界中，拒绝服务是致命的：</p>
<p>尽管其他类型的应用程序最终可以恢复，但智能合约可以通过其中一种攻击永远脱机。</p>
<p>许多方面导致拒绝服务，包括在作为交易接受方时恶意行为</p>
<p>人为地增加计算功能所需的gas，滥用访问控制访问智能合约的私人组件</p>
<p>利用混淆和疏忽，…这类攻击包括许多不同的变体，并可能在未来几年看到很多发展。</p>
<p>损失：估计为514,874 ETH（当时约3亿美元）</p>
<h3 id="真实世界影响-3"><a href="#真实世界影响-3" class="headerlink" title="真实世界影响"></a>真实世界影响</h3><p>政府<br><a href="https://www.reddit.com/r/ethereum/comments/4ghzhv/governmentals_1100_eth_jackpot_payout_is_stuck/" target="_blank" rel="noopener">https://www.reddit.com/r/ethereum/comments/4ghzhv/governmentals_1100_eth_jackpot_payout_is_stuck/</a></p>
<p>奇偶校验多信号钱包<br><a href="http://paritytech.io/a-postmortem-on-the-parity-multi-sig-library-self-destruct/" target="_blank" rel="noopener">http://paritytech.io/a-postmortem-on-the-parity-multi-sig-library-self-destruct/</a></p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>一个拍卖合约允许它的用户出价不同的资产。</p>
<p>为了投标，用户必须bid(uint object)用期望的以太数来调用函数。</p>
<p>拍卖合约将把以太保存在第三方保存中，直到对象的所有者接受投标或初始投标人取消。</p>
<p>这意味着拍卖合约必须在其余额中保留未解决出价的全部价值。</p>
<p>该拍卖合约还包括一个withdraw(uint amount)功能，它允许管理员从合约获取资金。</p>
<p>随着函数发送amount到硬编码地址，开发人员决定公开该函数。</p>
<p>一个攻击者看到了潜在的攻击和调用功能，指挥所有的合约的资金为其管理员。</p>
<p>这破坏了托管承诺并阻止了所有未决出价。</p>
<p>虽然管理员可能会将托管的钱退还给合约，但攻击者可以通过简单地撤回资金继续进行攻击。</p>
<h4 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h4><p>在下面的例子中（受以太王的启发<a href="http://blockchain.unica.it/projects/ethereum-survey/attacks.html#kotet）" target="_blank" rel="noopener">http://blockchain.unica.it/projects/ethereum-survey/attacks.html#kotet）</a><br>游戏合约的功能可以让你成为总统，如果你公开贿赂前一个。不幸的是，如果前总统是一个聪明的合约，并导致支付逆转，权力的转移将失败，恶意智能合约将永远保持总统。听起来像是对我的独裁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function becomePresident() payable &#123;</span><br><span class="line">    require(msg.value &gt;&#x3D; price); &#x2F;&#x2F; must pay the price to become president</span><br><span class="line">    president.transfer(price);   &#x2F;&#x2F; we pay the previous president</span><br><span class="line">    president &#x3D; msg.sender;      &#x2F;&#x2F; we crown the new president</span><br><span class="line">    price &#x3D; price * 2;           &#x2F;&#x2F; we double the price to become president</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第二个例子中，调用者可以决定下一个函数调用将奖励谁。由于for循环中有昂贵的指令，攻击者可能会引入太大的数字来迭代（由于以太坊中的气体阻塞限制），这将有效地阻止函数的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function selectNextWinners(uint256 _largestWinner) &#123;</span><br><span class="line">	for(uint256 i &#x3D; 0; i &lt; largestWinner, i++) &#123;</span><br><span class="line">		&#x2F;&#x2F; heavy code</span><br><span class="line">	&#125;</span><br><span class="line">	largestWinner &#x3D; _largestWinner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他资源-4"><a href="#其他资源-4" class="headerlink" title="其他资源"></a>其他资源</h3><p>奇偶Multisig被黑客入侵。再次<br><a href="https://medium.com/chain-cloud-company-blog/parity-multisig-hack-again-b46771eaa838" target="_blank" rel="noopener">https://medium.com/chain-cloud-company-blog/parity-multisig-hack-again-b46771eaa838</a></p>
<p>关于Parity multi-sig钱包漏洞和Cappasity令牌众包的声明<br><a href="https://blog.artoken.io/statement-on-the-parity-multi-sig-wallet-vulnerability-and-the-cappasity-artoken-crowdsale-b3a3fed2d567" target="_blank" rel="noopener">https://blog.artoken.io/statement-on-the-parity-multi-sig-wallet-vulnerability-and-the-cappasity-artoken-crowdsale-b3a3fed2d567</a></p>
<h1 id="6-错误随机"><a href="#6-错误随机" class="headerlink" title="6.错误随机"></a>6.错误随机</h1><p>也被称为没有什么是秘密的</p>
<p>合约对block.number年龄没有足够的验证，导致400个ETH输给一个未知的玩家，他在等待256个街区之前揭示了可预测的中奖号码。———-阿森尼罗托夫</p>
<p>以太坊的随机性很难找到。</p>
<p>虽然Solidity提供的功能和变量可以访问明显难以预测的值</p>
<p>但它们通常要么比看起来更公开，要么受到矿工影响。</p>
<p>由于这些随机性的来源在一定程度上是可预测的，所以恶意用户通常可以复制它并依靠其不可预知性来攻击该功能。</p>
<p>损失：超过400 ETH</p>
<h4 id="真实世界影响-4"><a href="#真实世界影响-4" class="headerlink" title="真实世界影响"></a>真实世界影响</h4><p>SmartBillions彩票<br><a href="https://www.reddit.com/r/ethereum/comments/74d3dc/smartbillions_lottery_contract_just_got_hacked/" target="_blank" rel="noopener">https://www.reddit.com/r/ethereum/comments/74d3dc/smartbillions_lottery_contract_just_got_hacked/</a></p>
<p>TheRun<br><a href="https://medium.com/@hrishiolickel/why-smart-contracts-fail-undiscovered-bugs-and-what-we-can-do-about-them-119aa2843007" target="_blank" rel="noopener">https://medium.com/@hrishiolickel/why-smart-contracts-fail-undiscovered-bugs-and-what-we-can-do-about-them-119aa2843007</a></p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><p>甲智能合约使用块号作为随机有游戏用的源。</p>
<p>攻击者创建一个恶意合约来检查当前的块号码是否是赢家。如果是这样，它就称为第一个智能合约以获胜; 由于该呼叫将是同一交易的一部分，因此两个合约中的块编号将保持不变。</p>
<p>攻击者只需要调用她的恶意合同，直到获胜。</p>
<h4 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h4><p>在第一个例子中，a private seed与iteration数字和keccak256散列函数结合使用来确定主叫方是否获胜。Eventhough的seed是private，它必须是通过交易在某个时间点设置，并因此在blockchain可见。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">uint256 private seed;</span><br><span class="line"></span><br><span class="line">function play() public payable &#123;</span><br><span class="line">	require(msg.value &gt;&#x3D; 1 ether);</span><br><span class="line">	iteration++;</span><br><span class="line">	uint randomNumber &#x3D; uint(keccak256(seed + iteration));</span><br><span class="line">	if (randomNumber % 2 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		msg.sender.transfer(this.balance);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这第二个例子中，block.blockhash正被用来生成一个随机数。</p>
<p>如果将该哈希值blockNumber设置为当前值block.number（出于显而易见的原因）并且因此设置为，则该哈希值未知0。</p>
<p>在blockNumber过去设置为超过256个块的情况下，它将始终为零。</p>
<p>最后，如果它被设置为一个以前的不太旧的区块号码，另一个智能合约可以访问相同的号码并将游戏合约作为同一交易的一部分进行调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function play() public payable &#123;</span><br><span class="line">	require(msg.value &gt;&#x3D; 1 ether);</span><br><span class="line">	if (block.blockhash(blockNumber) % 2 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">		msg.sender.transfer(this.balance);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="其他资源-5"><a href="#其他资源-5" class="headerlink" title="其他资源"></a>其他资源</h4><p>在以太坊智能合约中预测随机数<br><a href="https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620" target="_blank" rel="noopener">https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620</a></p>
<p>在以太坊随机<br><a href="https://blog.otlw.co/random-in-ethereum-50eefd09d33e" target="_blank" rel="noopener">https://blog.otlw.co/random-in-ethereum-50eefd09d33e</a></p>
<h1 id="7-前台运行"><a href="#7-前台运行" class="headerlink" title="7.前台运行"></a>7.前台运行</h1><p>也被称为检查时间与使用时间（TOCTOU），竞争条件，事务顺序依赖性（TOD）</p>
<p>事实证明，只需要150行左右的Python就可以获得一个正常运行的算法。——–Ivan Bogatyy</p>
<p>由于矿工总是通过代表外部拥有地址（EOA）的代码获得gas费用</p>
<p>因此用户可以指定更高的费用以便更快地开展交易。</p>
<p>由于以太坊区块链是公开的，每个人都可以看到其他人未决交易的内容。</p>
<p>这意味着，如果某个用户正在揭示拼图或其他有价值的秘密的解决方案，恶意用户可以窃取解决方案并以较高的费用复制其交易，以抢占原始解决方案。</p>
<p>如果智能合约的开发者不小心，这种情况会导致实际的和毁灭性的前端攻击。</p>
<h3 id="真实世界影响-5"><a href="#真实世界影响-5" class="headerlink" title="真实世界影响"></a>真实世界影响</h3><p>Bancor<br><a href="https://hackernoon.com/front-running-bancor-in-150-lines-of-python-with-ethereum-api-d5e2bfd0d798" target="_blank" rel="noopener">https://hackernoon.com/front-running-bancor-in-150-lines-of-python-with-ethereum-api-d5e2bfd0d798</a></p>
<p>ERC-20<br><a href="https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/" target="_blank" rel="noopener">https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/</a></p>
<p>TheRun<br><a href="https://www.dasp.co/" target="_blank" rel="noopener">https://www.dasp.co/</a></p>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><p>一个聪明的合约发布的RSA号（N = prime1 x prime2）。</p>
<p>对其submitSolution()公共功能的调用与权利prime1并prime2奖励来电者。</p>
<p>Alice成功地将RSA编号考虑在内，并提交解决方案。</p>
<p>有人在网络上看到Alice的交易（包含解决方案）等待被开采，并以较高的gas价格提交。</p>
<p>由于支付更高的费用，第二笔交易首先被矿工收回。该攻击者赢得奖金。</p>
<h4 id="其他资源-6"><a href="#其他资源-6" class="headerlink" title="其他资源"></a>其他资源</h4><p>在以太坊智能合约中预测随机数<br><a href="https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620" target="_blank" rel="noopener">https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620</a></p>
<p>虚拟和解的前卫，悲痛和危险<br><a href="https://blog.0xproject.com/front-running-griefing-and-the-perils-of-virtual-settlement-part-1-8554ab283e97" target="_blank" rel="noopener">https://blog.0xproject.com/front-running-griefing-and-the-perils-of-virtual-settlement-part-1-8554ab283e97</a></p>
<p>Frontrunning Bancor<br><a href="https://www.youtube.com/watch?v=RL2nE3huNiI" target="_blank" rel="noopener">https://www.youtube.com/watch?v=RL2nE3huNiI</a></p>
<h1 id="8-时间操纵"><a href="#8-时间操纵" class="headerlink" title="8.时间操纵"></a>8.时间操纵</h1><p>也被称为时间戳依赖</p>
<p>如果一位矿工持有合约的股份，他可以通过为他正在挖掘的矿区选择合适的时间戳来获得优势。——-Nicola Atzei，Massimo Bartoletti和Tiziana Cimoli</p>
<p>从锁定令牌销售到在特定时间为游戏解锁资金，合约有时需要依赖当前时间。</p>
<p>这通常通过Solidity中的block.timestamp别名或其别名完成now。</p>
<p>但是，这个价值从哪里来？来自矿工！</p>
<p>由于交易的矿工在报告采矿发生的时间方面具有回旋余地</p>
<p>所以良好的智能合约将避免强烈依赖所宣传的时间。</p>
<p>请注意，block.timestamp有时（错误）也会在随机数的生成中使用，如＃6所述。坏随机性。</p>
<h3 id="真实世界影响-6"><a href="#真实世界影响-6" class="headerlink" title="真实世界影响"></a>真实世界影响</h3><p>政府<br><a href="http://blockchain.unica.it/projects/ethereum-survey/attacks.html#governmental" target="_blank" rel="noopener">http://blockchain.unica.it/projects/ethereum-survey/attacks.html#governmental</a></p>
<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><p>一场比赛在今天午夜付出了第一名球员。<br>恶意的矿工包括他或她试图赢得比赛并将时间戳设置为午夜。<br>在午夜之前，矿工最终挖掘该块。当前的实时时间“足够接近”到午夜（当前为该块设置的时间戳），网络上的其他节点决定接受该块。</p>
<h4 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a>代码示例</h4><p>以下功能只接受特定日期之后的呼叫。由于矿工可以影响他们区块的时间戳（在一定程度上），他们可以尝试挖掘一个包含他们交易的区块，并在未来设定一个区块时间戳。如果足够接近，它将在网络上被接受，交易将在任何其他玩家试图赢得比赛之前给予矿工以太：</p>
<p>``<br>function play() public {<br>    require(now &gt; 1521763200 &amp;&amp; neverPlayed == true);<br>    neverPlayed = false;<br>    msg.sender.transfer(1500 ether);<br>}```</p>
<h4 id="其他资源-7"><a href="#其他资源-7" class="headerlink" title="其他资源"></a>其他资源</h4><p>对以太坊智能合约的攻击调查<br><a href="https://eprint.iacr.org/2016/1007" target="_blank" rel="noopener">https://eprint.iacr.org/2016/1007</a></p>
<p>在以太坊智能合约中预测随机数<br><a href="https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620" target="_blank" rel="noopener">https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620</a></p>
<p>让智能合约变得更聪明<br><a href="https://blog.acolyer.org/2017/02/23/making-smart-contracts-smarter/" target="_blank" rel="noopener">https://blog.acolyer.org/2017/02/23/making-smart-contracts-smarter/</a></p>
<h1 id="9短地址攻击"><a href="#9短地址攻击" class="headerlink" title="9短地址攻击"></a>9短地址攻击</h1><p>也被称为或涉及非连锁问题，客户端漏洞</p>
<p>为令牌传输准备数据的服务假定用户将输入20字节长的地址，但实际上并未检查地址的长度。—PawełBylica</p>
<p>短地址攻击是EVM本身接受不正确填充参数的副作用。</p>
<p>攻击者可以通过使用专门制作的地址来利用这一点，使编码错误的客户端在将它们包含在事务中之前不正确地对参数进行编码。</p>
<p>这是EVM问题还是客户问题？是否应该在智能合约中修复？</p>
<p>尽管每个人都有不同的观点，但事实是，这个问题可能会直接影响很多以太网。</p>
<p>虽然这个漏洞还没有被大规模利用，但它很好地证明了客户和以太坊区块链之间的交互带来的问题。</p>
<p>其他脱链问题存在：重要的是以太坊生态系统对特定的javascript前端，浏览器插件和公共节点的深度信任。</p>
<p>臭名昭着的链外利用被用于Coindash ICO的黑客在他们的网页上修改了公司的以太坊地址，诱骗参与者将ethers发送到攻击者的地址。</p>
<h2 id="发现时间表"><a href="#发现时间表" class="headerlink" title="发现时间表"></a>发现时间表</h2><p>2017/4/6——–如何通过阅读区块链来找到1000万美元<br><a href="https://blog.golemproject.net/how-to-find-10m-by-just-reading-blockchain-6ae9d39fcd95" target="_blank" rel="noopener">https://blog.golemproject.net/how-to-find-10m-by-just-reading-blockchain-6ae9d39fcd95</a><br>真实世界影响<br>未知交换（s）<br><a href="https://blog.golemproject.net/how-to-find-10m-by-just-reading-blockchain-6ae9d39fcd95" target="_blank" rel="noopener">https://blog.golemproject.net/how-to-find-10m-by-just-reading-blockchain-6ae9d39fcd95</a></p>
<p>示例<br>交易所API具有交易功能，可以接收收件人地址和金额。</p>
<p>然后，API transfer(address _to, uint256 _amount)使用填充参数与智能合约函数进行交互：它将12位零字节的地址（预期的20字节长度）预先设置为32字节长</p>
<p>Bob（0x3bdde1e9fbaef2579dd63e2abbf0be445ab93f00）要求Alice转让他20个代币。他恶意地将她的地址截断以消除尾随的零。</p>
<p>Alice使用交换API和Bob（0x3bdde1e9fbaef2579dd63e2abbf0be445ab93f）的较短的19字节地址。</p>
<p>API用12个零字节填充地址，使其成为31个字节而不是32个字节。有效地窃取以下_amount参数中的一个字节。</p>
<p>最终，执行智能合约代码的EVM将会注意到数据未被正确填充，并会在_amount参数末尾添加丢失的字节。有效地传输256倍以上的令牌。</p>
<h4 id="其他资源-8"><a href="#其他资源-8" class="headerlink" title="其他资源"></a>其他资源</h4><p>ERC20短地址攻击说明<br><a href="http://vessenes.com/the-erc20-short-address-attack-explained/" target="_blank" rel="noopener">http://vessenes.com/the-erc20-short-address-attack-explained/</a></p>
<p>分析ERC20短地址攻击<br><a href="https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/" target="_blank" rel="noopener">https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/</a></p>
<p>智能合约短地址攻击缓解失败<br><a href="https://blog.coinfabrik.com/smart-contract-short-address-attack-mitigation-failure/" target="_blank" rel="noopener">https://blog.coinfabrik.com/smart-contract-short-address-attack-mitigation-failure/</a></p>
<p>从标记中删除短地址攻击检查<br><a href="https://github.com/OpenZeppelin/zeppelin-solidity/issues/261" target="_blank" rel="noopener">https://github.com/OpenZeppelin/zeppelin-solidity/issues/261</a></p>
<h1 id="10-未知的未知物"><a href="#10-未知的未知物" class="headerlink" title="10.未知的未知物"></a>10.未知的未知物</h1><p>我们相信更多的安全审计或更多的测试将没有什么区别。主要问题是评审人员不知道要寻找什么。——Christoph Jentzsch</p>
<ul>
<li>以太坊仍处于起步阶段。</li>
<li>用于开发智能合约的主要语言Solidity尚未达到稳定版本</li>
<li>而生态系统的工具仍处于试验阶段。</li>
<li>一些最具破坏性的智能合约漏洞使每个人都感到惊讶</li>
<li>并且没有理由相信不会有另一个同样出乎意料或同样具有破坏性的漏洞。</li>
<li>只要投资者决定将大量资金用于复杂而轻微审计的代码</li>
<li>我们将继续看到新发现导致可怕后果。</li>
<li>正式验证智能合约的方法尚不成熟，但它们似乎具有很好的前景，可以作为摆脱今天不稳定现状的方式。</li>
<li>随着新类型的漏洞不断被发现，开发人员需要继续努力</li>
<li>并且需要开发新工具来在坏人之前找到它们。</li>
<li>这个Top10可能会迅速发展，直到智能合约开发达到稳定和成熟的状态。</li>
</ul>
<h1 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h1><p><a href="https://www.dasp.co/" target="_blank" rel="noopener">https://www.dasp.co/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.yi-diandian.com/2020/04/06/dasp/" data-id="ck8nv1ajp000hgkh53eexfig8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DASP/" rel="tag">DASP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TOP10/" rel="tag">TOP10</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/" rel="tag">智能合约</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ctfwriteup2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/06/ctfwriteup2/" class="article-date">
  <time datetime="2020-04-06T02:28:14.237Z" itemprop="datePublished">2020-04-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CTF/">CTF</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/06/ctfwriteup2/">WriteUp-Web暴力破解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="web暴力破解"><a href="#web暴力破解" class="headerlink" title="web暴力破解"></a>web暴力破解</h1><p>访问，发现是一个web的登录验证，对登录过程使用BurpSuite进行抓包</p>
<p><img src="https://raw.githubusercontent.com/jeansgit/jeansgit.github.io/master/2020/03/29/ctfwriteup2/web1.png" alt></p>
<p>从登录数据包可以看到，认证请求通过base64进行加密<br><img src="https://raw.githubusercontent.com/jeansgit/jeansgit.github.io/master/2020/03/29/ctfwriteup2/web2.png" alt></p>
<p>解密后的值为：<br><img src="https://raw.githubusercontent.com/jeansgit/jeansgit.github.io/master/2020/03/29/ctfwriteup2/web3.png" alt></p>
<p>将该数据包发送到intruder模块进行爆破</p>
<p>选中我们的值，admin:123456，对该值添加变量识别</p>
<p><img src="https://raw.githubusercontent.com/jeansgit/jeansgit.github.io/master/2020/03/29/ctfwriteup2/web4.png" alt></p>
<p>由于这里是对用户名:密码（如admin:123456）  进行base64加密，我们需要构造用户名:密码字典<br><img src="https://raw.githubusercontent.com/jeansgit/jeansgit.github.io/master/2020/03/29/ctfwriteup2/web5.png" alt></p>
<p>在payload页面，导入我们构造的字典：</p>
<p><img src="https://raw.githubusercontent.com/jeansgit/jeansgit.github.io/master/2020/03/29/ctfwriteup2/web6.png" alt><br>在payload processing 选择base64加密</p>
<p><img src="https://raw.githubusercontent.com/jeansgit/jeansgit.github.io/master/2020/03/29/ctfwriteup2/web7.png" alt></p>
<p>这里可设置线程，默认为5。<br><img src="https://raw.githubusercontent.com/jeansgit/jeansgit.github.io/master/2020/03/29/ctfwriteup2/web8.png" alt></p>
<p>配置完成后，点击右上角的start attack进行爆破：<br><img src="https://raw.githubusercontent.com/jeansgit/jeansgit.github.io/master/2020/03/29/ctfwriteup2/web9.png" alt></p>
<p>以下为爆破过程：<br><img src="https://raw.githubusercontent.com/jeansgit/jeansgit.github.io/master/2020/03/29/ctfwriteup2/web10.png" alt></p>
<p>爆破完成即可获取flag。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.yi-diandian.com/2020/04/06/ctfwriteup2/" data-id="ck8nv1ajm000agkh5gr4j9iuf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CTF/" rel="tag">CTF</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/" rel="tag">暴力破解</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ctfwriteup" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/06/ctfwriteup/" class="article-date">
  <time datetime="2020-04-06T02:28:14.235Z" itemprop="datePublished">2020-04-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CTF/">CTF</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/06/ctfwriteup/">WriteUp-源代码审计</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$output &#x3D; &quot;&quot;;</span><br><span class="line">if (isset($_GET[&#39;pass&#39;])) &#123;</span><br><span class="line">  if(!preg_match(&#39;&#x2F;^[^\W_]+$&#x2F;&#39;, $_GET[&#39;pass&#39;])) &#123;</span><br><span class="line">    $output &#x3D; &quot;Don&#39;t hack me please :(&quot;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    $pass &#x3D; md5(&quot;admin1674227342&quot;);</span><br><span class="line">    if ((((((((($_GET[&#39;pass&#39;] &#x3D;&#x3D; $pass)))) &amp;&amp; (((($pass !&#x3D;&#x3D; $_GET[&#39;pass&#39;]))))) || ((((($pass &#x3D;&#x3D; $_GET[&#39;pass&#39;])))) &amp;&amp; ((($_GET[&#39;pass&#39;] !&#x3D;&#x3D; $pass)))))))) &#123; </span><br><span class="line">      if (strlen($pass) &#x3D;&#x3D; strlen($_GET[&#39;pass&#39;])) &#123;</span><br><span class="line">        $output &#x3D; &quot;&lt;div class&#x3D;&#39;alert alert-success&#39;&gt;ctf&#123;xxx&#125;&lt;&#x2F;div&gt;&quot;;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        $output &#x3D; &quot;&lt;div class&#x3D;&#39;alert alert-danger&#39;&gt;Wrong password&lt;&#x2F;div&gt;&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      $output &#x3D; &quot;&lt;div class&#x3D;&#39;alert alert-danger&#39;&gt;Wrong password&lt;&#x2F;div&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">echo $output;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>这里建议是把代码放到自己本地的环境进行调试（如phpstudy）</p>
<p>代码中的$pass = md5(“admin1674227342”); </p>
<p>我们进入<a href="https://cmd5.com/hash.aspx?s=" target="_blank" rel="noopener">https://cmd5.com/hash.aspx?s=</a> 对该字符串进行加密</p>
<p>即变量$pass的值为0e463854177790028825434984462555</p>
<p>$_GET[‘pass’]为通过URL中GET参数pass获取到的值。</p>
<h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><p>从代码中，我们可以读出，要想获取到flag，需满足以下几个条件：</p>
<ul>
<li><p>1、isset($_GET[‘pass’] 为True （即不为空）</p>
</li>
<li><p>2、!preg_match(‘/^[^\W_]+$/‘, $_GET[‘pass’]) 为False，<br>   即preg_match(‘/^[^\W_]+$/‘, $_GET[‘pass’])为True </p>
</li>
<li><p>3、((((((((($_GET[‘pass’] == $pass)))) &amp;&amp; (((($pass !== $_GET[‘pass’]))))) || ((((($pass == $_GET[‘pass’])))) &amp;&amp; ((($_GET[‘pass’] !== $pass)))))))) 得为True，即</p>
</li>
<li><p>($_GET[‘pass’] == $pass)))) &amp;&amp; (((($pass !== $_GET[‘pass’]))))) 或((((($pass == $_GET[‘pass’])))) &amp;&amp; ((($_GET[‘pass’] !== $pass)))) 两者取值，其中一定有一个为True</p>
</li>
<li><p>4、strlen($pass) == strlen($_GET[‘pass’])，为True</p>
</li>
</ul>
<p>只有当同时满足以上条件，才会将flag显示出来。</p>
<h1 id="PHP的弱类型"><a href="#PHP的弱类型" class="headerlink" title="PHP的弱类型"></a>PHP的弱类型</h1><p>（参考<a href="https://www.cnblogs.com/cnsec/p/11830674.html，" target="_blank" rel="noopener">https://www.cnblogs.com/cnsec/p/11830674.html，</a><br><a href="https://blog.csdn.net/auuuuuuuu/article/details/79621635）" target="_blank" rel="noopener">https://blog.csdn.net/auuuuuuuu/article/details/79621635）</a><br>php有两种比较方式,一种是“= =”一种是“= = =”，“= =”：会把两端变量类型转换成相同的，在进行比较。<br>“= = =”：会先判断两端变量类型是否相同，在进行比较。</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>pass字符串长度要为32位，构造<br><a href="http://127.0.0.1/code.php?pass=0e111111111111111111111111111111" target="_blank" rel="noopener">http://127.0.0.1/code.php?pass=0e111111111111111111111111111111</a></p>
<p>$_GET[‘pass’] == $pass， 此时为True（两者的值均可看成科学计数法，值为0）<br>$pass !== $_GET[‘pass’] , 此时是两个字符串进行比较，两者不相等，故为True</p>
<p>即得出：<br>((((((((($_GET[‘pass’] == $pass)))) &amp;&amp; (((($pass !== $_GET[‘pass’]))))) || ((((($pass == $_GET[‘pass’])))) &amp;&amp; ((($_GET[‘pass’] !== $pass)))))))) 取值为True,且值的长度为32位。</p>
<p>故满足条件。<br><img src="https://raw.githubusercontent.com/jeansgit/jeansgit.github.io/master/2020/03/29/ctfwriteup/ctfcode.png" alt></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.yi-diandian.com/2020/04/06/ctfwriteup/" data-id="ck8nv1ajl0009gkh5b3qjfas6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CTF/" rel="tag">CTF</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-btc4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/06/btc4/" class="article-date">
  <time datetime="2020-04-06T02:28:14.232Z" itemprop="datePublished">2020-04-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/06/btc4/">EOS节点远程代码执行漏洞</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>5月29日，360安全研究团队发现了EOS区块链系统的一个越界写缓冲区溢出漏洞，通过该漏洞可直接在节点服务器执行任意代码并完全控制服务器。</p>
<h1 id="EOS简介"><a href="#EOS简介" class="headerlink" title="EOS简介"></a>EOS简介</h1><p>既然是EOS区块链系统的漏洞，那我们简单了解一下，什么是EOS？</p>
<p>EOS: Enterprise Operation System，即为商用分布式应用设计的一款区块链操作系统。</p>
<p>EOS是引入的一种新的区块链架构，旨在实现分布式应用的性能扩展。</p>
<p>注意，它并不是像比特币和以太坊那样的货币，而是基于EOS软件项目之上发布的代币，被称为区块链3.0。（百度百科）</p>
<p>更详细的信息可以访问EOS官网地址<a href="https://eos.io/" target="_blank" rel="noopener">https://eos.io/</a> 查看。<br>EOS GitHub地址：<a href="https://github.com/EOSIO/eos" target="_blank" rel="noopener">https://github.com/EOSIO/eos</a><br><img src="https://imgsrc.baidu.com/baike/pic/item/838ba61ea8d3fd1f55fb04ae3c4e251f94ca5fb7.jpg" alt></p>
<h1 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h1><p>EOS区块链系统在解析智能合约WASM文件时，产生了一个越界写缓冲区溢出漏洞。</p>
<p>通过该漏洞，攻击者可以上传恶意的智能合约代码到节点服务器，然后当节点服务器解析恶意的智能合约时</p>
<p>攻击者就能够在节点上执行任意代码并完全控制节点服务器。</p>
<p>攻击者控制节点服务器后，攻击者可以将恶意智能合约打包进新的区块，而其他新的节点会同步区块内容，导致可攻击和控制其他新的节点，最终攻击和控制整个EOS区块链网络。</p>
<h1 id="漏洞时间线"><a href="#漏洞时间线" class="headerlink" title="漏洞时间线"></a>漏洞时间线</h1><p>2018/5/11———-发现EOS越界写缓冲区溢出漏洞<br>2018/5/28———-调试并成功开发出完整攻破EOS超级节点的漏洞验证代码<br>2018/5/28———-将漏洞细节报告给EOS官方<br>2018/5/29———-EOS官方在GitHub托管代码库中修复该漏洞，并关闭了问题跟踪<br>2018/5/29———-提醒EOS官方，漏洞未完全修复<br>2018/5/30———-官方已修复漏洞<br>以下是360安全人员和官方沟通的一些细节：<br><img src="http://blogs.360.cn/wp-content/uploads/2018/05/001.jpg" alt></p>
<p>提供邮箱接收报告。</p>
<p><img src="http://blogs.360.cn/wp-content/uploads/2018/05/002.jpg" alt></p>
<h1 id="漏洞细节"><a href="#漏洞细节" class="headerlink" title="漏洞细节"></a>漏洞细节</h1><p>漏洞存在于libraries/chain/webassembly/binaryen.cpp文件的78行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Function binaryen_runtime::instantiate_module:</span><br><span class="line">for (auto&amp; segment : module-&gt;table.segments) </span><br><span class="line">&#123;</span><br><span class="line">	Address offset &#x3D; ConstantExpressionRunner&lt;TrivialGlobalManager&gt;(globals).visit(segment.offset).value.geti32();</span><br><span class="line">	assert(offset + segment.data.size() &lt;&#x3D; module-&gt;table.initial);</span><br><span class="line">	for (size_t i &#x3D; 0; i !&#x3D; segment.data.size(); ++i) </span><br><span class="line">	&#123;</span><br><span class="line">		table[offset + i] &#x3D; segment.data[i]; &lt;&#x3D; OOB write here !</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的table是一个std :: vector包含在函数表中的名称，在将元素存储到table中时，|offset| 字段没有被正确检查。</p>
<p>注意在设置该值之前是有一个assert 断言的，它会检查偏移量，但不幸的是assert 仅适用于Debug版本，不适用于发布版本。</p>
<p>table.resize(module-&gt;table.initial);|module-&gt;table.initial| 这个代码片段读取的值是根据函数表声明，在WASM文件中的读取时，该字段的有效值为0〜1024。</p>
<p>|offset| 字段的值是根据数据段从WASM文件中读取的，它是一个带符号的32位值。</p>
<p>所以通过这个漏洞，可以在table向量之后的内存，越界写入一定范围的内容。</p>
<h1 id="漏洞演示"><a href="#漏洞演示" class="headerlink" title="漏洞演示"></a>漏洞演示</h1><p>利用该漏洞可以在nodeos进程中实现远程代码执行</p>
<p>漏洞利用方法：<br>上传恶意智能合约代码到受害节点服务器<br>让节点服务器解析恶意智能合约<br>在真正的攻击中，攻击者可能会向EOS主网络发布恶意智能合约代码。</p>
<p>EOS超级节点一单解析恶意智能合约触发漏洞，攻击者能够完全控制这个节点服务器。</p>
<p>攻击者控制节点后，可进行的操作:</p>
<ul>
<li>窃取超级节点的私钥</li>
<li>控制新区块的内容</li>
<li>打包恶意智能合约到新的区块并发布然后攻击其他的节点</li>
<li>导致整个网络汇总的所有节点受攻击并被控制</li>
<li>360安全人员编写了概念性的漏洞验证程序，然后在64位Ubuntu系统上进行了演示。</li>
</ul>
<h1 id="具体攻击过程："><a href="#具体攻击过程：" class="headerlink" title="具体攻击过程："></a>具体攻击过程：</h1><ul>
<li>攻击者将恶意智能合约上传到节点服务器</li>
<li>节点服务器解析引发漏洞的恶意智能合约</li>
<li>使用越界写入的代码，覆盖WASM模块实例的WASM内存缓冲区</li>
<li>在恶意WASM代码的帮助下，成功实现了任意内存读/写操作</li>
<li>可绕过常见的操作系统攻击缓解技术</li>
<li>反弹shell给攻击者</li>
</ul>
<h1 id="演示视频"><a href="#演示视频" class="headerlink" title="演示视频"></a>演示视频</h1><p><a href="http://v.youku.com/v_show/id_XMzYzMTg1NjYwMA==.html" target="_blank" rel="noopener">http://v.youku.com/v_show/id_XMzYzMTg1NjYwMA==.html</a></p>
<h1 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h1><p><a href="http://blogs.360.cn/blog/eos-node-remote-code-execution-vulnerability/" target="_blank" rel="noopener">http://blogs.360.cn/blog/eos-node-remote-code-execution-vulnerability/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.yi-diandian.com/2020/04/06/btc4/" data-id="ck8nv1aji0006gkh559u4aw47" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/EOS/" rel="tag">EOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/" rel="tag">远程代码执行漏洞</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-btc3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/06/btc3/" class="article-date">
  <time datetime="2020-04-06T02:28:14.230Z" itemprop="datePublished">2020-04-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/06/btc3/">BeautyChain智能合约中的毁灭性漏洞</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="安全事件"><a href="#安全事件" class="headerlink" title="安全事件"></a>安全事件</h1><p>最近，智能合约漏洞很火。<br>让我们再来看一下4月22日BeautyChain（BEC）的智能合约中一个毁灭性的漏洞。</p>
<p>*<em>BeautyChain团队宣布，BEC代币在4月22日出现异常。攻击者通过智能合约漏洞成功转账了10^58 BEC到两个指定的地址。<br>*</em><br>具体交易详情<a href="https://etherscan.io/tx/0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f" target="_blank" rel="noopener">https://etherscan.io/tx/0xad89ff16fd1ebe3a0a7cf4ed282302c06626c1af33221ebe0d3a470aba4a660f</a></p>
<p>攻击者到底是怎么攻击的？为什么能转账这么大的BEC？</p>
<h1 id="智能合约代码"><a href="#智能合约代码" class="headerlink" title="智能合约代码"></a>智能合约代码</h1><p>首先我们来看BEC转账的智能合约代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) &#123;</span><br><span class="line">    uint cnt &#x3D; _receivers.length;</span><br><span class="line">    uint256 amount &#x3D; uint256(cnt) * _value;</span><br><span class="line">    require(cnt &gt; 0 &amp;&amp; cnt &lt;&#x3D; 20);</span><br><span class="line">    require(_value &gt; 0 &amp;&amp; balances[msg.sender] &gt;&#x3D; amount);</span><br><span class="line"></span><br><span class="line">    balances[msg.sender] &#x3D; balances[msg.sender].sub(amount);</span><br><span class="line">    for (uint i &#x3D; 0; i &lt; cnt; i++) &#123;</span><br><span class="line">        balances[_receivers[i]] &#x3D; balances[_receivers[i]].add(_value);</span><br><span class="line">        Transfer(msg.sender, _receivers[i], _value);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>以上的代码是Solidity语言，是一门面向合约的，为实现智能合约而创建的高级编程语言。</p>
<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>在读代码之前我们先来简单了解一下以下几个变量类型(Solidity):</p>
<p>address<br>160位的值，且不允许任何算数操作。</p>
<p>uint 8<br>8位无符号整数，范围是0到2^8减1 (0-255)</p>
<p>uint256<br>256位无符号整数，范围是0到2^256减1<br>(0-115792089237316195423570985008687907853269984665640564039457584007913129639935)</p>
<p>敲黑板，玩手机的同学注意看这里，这里是考试重点哦<br>那么，我们请看如下神奇的化学反应</p>
<h2 id="定义变量uint-a"><a href="#定义变量uint-a" class="headerlink" title="定义变量uint a"></a>定义变量uint a</h2><p>a的取值范围是0到255</p>
<p>当a=255，我们对a加 1，a会变成 0。<br>当a=255，我们对a加 2，a会变成 1。<br>当a=0，我们对a减 1，a会变成 255。<br>当a=0，我们对a减 2，a会变成 254。</p>
<p>a的值超过了它实际的取值范围，然后会得出后面的值，这种情况叫溢出。</p>
<h2 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h2><p>知道了这几个变量类型，下面我们一行一行的来读这段代码。</p>
<h3 id="第一行"><a href="#第一行" class="headerlink" title="第一行"></a>第一行</h3><p>function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool)</p>
<p>==函数有两个参数:==</p>
<p>_receivers ———-转账接收人，address类型的变量数组，是一个160位的值。<br>_value —————转账数量，uint256的状态变量，256位的无符号整数。<br>定义函数batchTransfer，功能主要是实现转账，接收两个参数，定义了参数的取值范围。</p>
<h3 id="第二行"><a href="#第二行" class="headerlink" title="第二行"></a>第二行</h3><p>uint cnt = _receivers.length;</p>
<p>计算接收人地址对应地址数组的长度，即转账给多少人。</p>
<h3 id="第三行"><a href="#第三行" class="headerlink" title="第三行"></a>第三行</h3><p>uint256 amount = uint256(cnt) * _value;</p>
<p>把unit类型的cnt参数值强制转换为uint256然后乘以转账数量_value 并赋值给uint256类型的amount变量。</p>
<h3 id="第四行"><a href="#第四行" class="headerlink" title="第四行"></a>第四行</h3><p>require(cnt &gt; 0 &amp;&amp; cnt &lt;= 20);</p>
<p>require函数</p>
<p>require的入参判定为 false，则终止函数，恢复所有对状态和以太币账户的变动，并且也不会消耗 gas 。</p>
<p>判断cnt是否大于0且cnt是否小于等于20</p>
<h3 id="第五行"><a href="#第五行" class="headerlink" title="第五行"></a>第五行</h3><p>require(_value &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount);</p>
<p>==参数解读:==</p>
<p>_value————————–转账数量<br>balances[msg.sender]———转账人余额<br>amount————————转账总数量<br>判断_value是否大于0且转账人的余额balances[msg.sender]大于等于转账总金额amount</p>
<h3 id="第六行"><a href="#第六行" class="headerlink" title="第六行"></a>第六行</h3><p>balances[msg.sender] = balances[msg.sender].sub(amount);</p>
<p>计算转账人的余额，使用当前余额balances[msg.sender]减去转账总数量</p>
<h3 id="第七行"><a href="#第七行" class="headerlink" title="第七行"></a>第七行</h3><p>for (uint i = 0; i &lt; cnt; i++) {</p>
<p>这里是一个循环，循环次数为cnt（遍历转账地址）</p>
<h3 id="第八行"><a href="#第八行" class="headerlink" title="第八行"></a>第八行</h3><p>balances[_receivers[i]] = balances[_receivers[i]].add(_value);</p>
<p>当i有具体的值时，balances[_receivers[i]]表示转账接收人，这里是表示转账人给转账接收人_value数量的币。</p>
<h3 id="第九行"><a href="#第九行" class="headerlink" title="第九行"></a>第九行</h3><p>Transfer(msg.sender, _receivers[i], _value);</p>
<p>保存转账记录</p>
<h3 id="第十行"><a href="#第十行" class="headerlink" title="第十行"></a>第十行</h3><p>return true;</p>
<p>函数返回为True</p>
<h2 id="代码流程"><a href="#代码流程" class="headerlink" title="代码流程"></a>代码流程</h2><p>OK，我们读了完整的代码，接下来请看一个流程图</p>
<p><img src="https://s1.ax1x.com/2018/05/28/C4tumq.png" alt></p>
<p>函数的流程是这样，那么攻击者到底是怎么攻击的呢？他为什么这么秀？同样都是九年义务教育……</p>
<p>攻击过程<br>其实，他只是细心了一点，所使用的攻击方法并不高明啊，你且听我慢慢道来，注意看，别走神啊。</p>
<p>交易详情<br>我们首先看这笔详细的交易：<br><img src="https://s1.ax1x.com/2018/05/28/C4tJ1J.png" alt></p>
<h4 id="好了，我们从图可以看到"><a href="#好了，我们从图可以看到" class="headerlink" title="好了，我们从图可以看到"></a>好了，我们从图可以看到</h4><p>转账接收人有两个地址，即balances[_receivers]:</p>
<p>000000000000000000000000b4d30cac5124b46c2df0cf3e3e1be05f42119033<br>0000000000000000000000000e823ffe018727585eaf5bc769fa80472f76c3d7</p>
<p>转账数量为_value:</p>
<p>8000000000000000000000000000000000000000000000000000000000000000（十六进制）</p>
<p>转10进制为</p>
<p>57896044618658097711785492504343953926634992332820282019728792003956564819968</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>OK，接下来我们来走函数流程</p>
<h3 id="第一行-1"><a href="#第一行-1" class="headerlink" title="第一行"></a>第一行</h3><p>function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool)</p>
<p>正常执行</p>
<h3 id="第二行-1"><a href="#第二行-1" class="headerlink" title="第二行"></a>第二行</h3><p>uint cnt = _receivers.length<br>由于这里有两个转账接收人地址，address数组长度为2，所以cnt为2，类型为uint</p>
<h3 id="第三行-1"><a href="#第三行-1" class="headerlink" title="第三行"></a>第三行</h3><p>uint256 amount = uint256(cnt) * _value;</p>
<p>_value=57896044618658097711785492504343953926634992332820282019728792003956564819968<br>cnt=2<br>两者相乘得到amount，类型为uint256<br><img src="https://s1.ax1x.com/2018/05/28/C4NSCF.png" alt></p>
<p>即amount=115792089237316195423570985008687907853269984665640564039457584007913129639936</p>
<p>考试重点用上了，记不住的同学去前面看看。</p>
<p>amount的类型为uint256，那么按照理论，它的最大取值是0到2^256减1，即</p>
<p>115792089237316195423570985008687907853269984665640564039457584007913129639935</p>
<p>所以！！！<br>amount瞬间从115792089237316195423570985008687907853269984665640564039457584007913129639936变成了0<br>第三行得到的结果：amount=0</p>
<h3 id="第四行-1"><a href="#第四行-1" class="headerlink" title="第四行"></a>第四行</h3><p>require(cnt &gt; 0 &amp;&amp; cnt &lt;= 20);</p>
<p>cnt=2，2肯定大于0，2当然也小于等于20<br><strong>所以这个条件成立，require函数返回值为True。</strong></p>
<h3 id="第五行-1"><a href="#第五行-1" class="headerlink" title="第五行"></a>第五行</h3><p>require(_value &gt; 0 &amp;&amp; balances[msg.sender] &gt;= amount);</p>
<p>_value=57896044618658097711785492504343953926634992332820282019728792003956564819968</p>
<p>_value肯定是大于0，转账人的余额balances[msg.sender]肯定是大于等于0的。<br><strong>所以这个条件同样成立，require函数返回值为True。</strong></p>
<h3 id="第六行-1"><a href="#第六行-1" class="headerlink" title="第六行"></a>第六行</h3><p>balances[msg.sender] = balances[msg.sender].sub(amount);</p>
<p>前面的条件都成立，那么代码会执行到这。</p>
<p>这行代码是求转账人转完账以后剩下的余额，amount为0 ，<strong>那么转账人的余额其实没变！！！</strong></p>
<h3 id="第七行-1"><a href="#第七行-1" class="headerlink" title="第七行"></a>第七行</h3><p>for (uint i = 0; i &lt; cnt; i++)</p>
<p>cnt=2，该行代码表示执行两次后面的操作</p>
<h3 id="第八行-1"><a href="#第八行-1" class="headerlink" title="第八行"></a>第八行</h3><p>balances[_receivers[i]] = balances[_receivers[i]].add(_value);<br>i=0时，转账接收人balances[_receivers[0]]的余额加_value<br>i=1时，转账接收人balances[_receivers[1]]的余额加_value</p>
<p>看到这里其实我们就很明白了吧。</p>
<p>攻击者给以下两个转账接收人</p>
<p><strong>000000000000000000000000b4d30cac5124b46c2df0cf3e3e1be05f42119033<br>0000000000000000000000000e823ffe018727585eaf5bc769fa80472f76c3d7</strong></p>
<p>转了<br>_value=57896044618658097711785492504343953926634992332820282019728792003956564819968个币</p>
<p>更可恶的是，攻击者执行完这个操作，转账人的余额根本没变，看代码第六行的执行结果。</p>
<h3 id="第九行-1"><a href="#第九行-1" class="headerlink" title="第九行"></a>第九行</h3><p>Transfer(msg.sender, _receivers[i], _value);<br>这里只是把上面两个转账记录保存。</p>
<h3 id="第十行-1"><a href="#第十行-1" class="headerlink" title="第十行"></a>第十行</h3><p>return true;</p>
<p>函数返回为True</p>
<p>小结<br>千里之堤毁于蚁穴！<br>就一个溢出漏洞，导致BEC的市值瞬间变0</p>
<p>这么傻的问题，写代码的人是写睡着了吗？？？</p>
<p>不，其实他根本没睡着啊，人家还用了SafeMath里的add函数和sub函数</p>
<p><img src="https://s1.ax1x.com/2018/05/28/C4UPJS.png" alt></p>
<p>我们看看什么是SafeMath函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @title SafeMath</span><br><span class="line"> * @dev Math operations with safety checks that throw on error</span><br><span class="line"> *&#x2F;</span><br><span class="line">library SafeMath &#123;</span><br><span class="line">  function mul(uint256 a, uint256 b) internal constant returns (uint256) &#123;</span><br><span class="line">    uint256 c &#x3D; a * b;</span><br><span class="line">    assert(a &#x3D;&#x3D; 0 || c &#x2F; a &#x3D;&#x3D; b);</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line">  function div(uint256 a, uint256 b) internal constant returns (uint256) &#123;</span><br><span class="line">    &#x2F;&#x2F; assert(b &gt; 0); &#x2F;&#x2F; Solidity automatically throws when dividing by 0</span><br><span class="line">    uint256 c &#x3D; a &#x2F; b;</span><br><span class="line">    &#x2F;&#x2F; assert(a &#x3D;&#x3D; b * c + a % b); &#x2F;&#x2F; There is no case in which this doesn&#39;t hold</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function sub(uint256 a, uint256 b) internal constant returns (uint256) &#123;</span><br><span class="line">    assert(b &lt;&#x3D; a);</span><br><span class="line">    return a - b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function add(uint256 a, uint256 b) internal constant returns (uint256) &#123;</span><br><span class="line">    uint256 c &#x3D; a + b;</span><br><span class="line">    assert(c &gt;&#x3D; a);</span><br><span class="line">    return c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意看这一段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function mul(uint256 a, uint256 b) internal constant returns (uint256) &#123;</span><br><span class="line">   uint256 c &#x3D; a * b;</span><br><span class="line">   assert(a &#x3D;&#x3D; 0 || c &#x2F; a &#x3D;&#x3D; b);</span><br><span class="line">   return c;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这里是乘法计算，计算出乘法的结果后会用assert函数去验证结果是否正确。</p>
<p><strong>回到我们前面的第三行代码执行后的结果</strong></p>
<p>_value=57896044618658097711785492504343953926634992332820282019728792003956564819968<br>cnt=2</p>
<p>两者相乘得到amount，类型为uint256</p>
<p>由于溢出，amount=0</p>
<p>赋值给mul函数即</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c&#x3D;amount，而amount&#x3D;0，则c&#x3D;0</span><br><span class="line">a&#x3D;cnt, 而cnt&#x3D;2，则a&#x3D;2</span><br><span class="line">b&#x3D;_value</span><br><span class="line">得出</span><br><span class="line">b&#x3D;57896044618658097711785492504343953926634992332820282019728792003956564819968</span><br></pre></td></tr></table></figure>
<p>那么c/a==b这个式子不成立，导致assert函数执行会报错，assert报错，那么就不会执行后面的代码，也就不会发生溢出。</p>
<p><strong>也就是说，写这段代码的人，加减法他用了SafeMath里面的add函数和sub函数，但是却没有用里面的乘法函数mul</strong></p>
<h1 id="如何防止这样的漏洞？"><a href="#如何防止这样的漏洞？" class="headerlink" title="如何防止这样的漏洞？"></a>如何防止这样的漏洞？</h1><ul>
<li>肯定是要用SafeMath函数啊，你加减法用了，乘法不用，你咋这么皮呢</li>
<li>代码上线前要做代码审计啊亲，强调多少遍了！</li>
<li>合理使用变量类型，了解清楚变量的范围</li>
<li>一定要考虑到溢出！一定要考虑到溢出！一定要考虑到溢出！重要的事情说三遍。</li>
<li>写这么通俗易懂，你应该看懂了吧？？?</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.yi-diandian.com/2020/04/06/btc3/" data-id="ck8nv1aje0004gkh5705t1egm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag">区块链</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/" rel="tag">智能合约</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BC%8F%E6%B4%9E/" rel="tag">漏洞</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-btc2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/06/btc2/" class="article-date">
  <time datetime="2020-04-06T02:28:14.227Z" itemprop="datePublished">2020-04-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/06/btc2/">区块链安全解决方案</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>谈及区块链安全，不应该仅仅局限于区块链本身，它的使用者及其衍生的东西都需要我们重点关注。<br><img src="https://s1.ax1x.com/2018/05/16/Cy9s0I.md.png" alt></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.yi-diandian.com/2020/04/06/btc2/" data-id="ck8nv1aj30000gkh57g6j04x2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag">区块链</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%89%E5%85%A8/" rel="tag">安全</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-btc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/06/btc/" class="article-date">
  <time datetime="2020-04-06T02:28:14.217Z" itemprop="datePublished">2020-04-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/06/btc/">区块链初识之比特币</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="比特币知识（一）"><a href="#比特币知识（一）" class="headerlink" title="比特币知识（一）"></a>比特币知识（一）</h1><p><a href="http://blog.yuccn.net/archives/64.html" target="_blank" rel="noopener">http://blog.yuccn.net/archives/64.html</a></p>
<p>比特币：p2p形式的数字货币，网上虚拟货币的一种<br>比特币是一种总量恒定在2100万的数字货币，特点是“去中心化”、”全球流通” 、“匿名化” 等<br>严格来说，比特币不是一种货币，而是一个账本<br>更准确说是一个基于互联网分布式存储的一种帐本系统。</p>
<p>比特币的中心思想是去中心化，或者多中心化，多个中心达成共识一起的记账</p>
<p>比特币系统:哈希值计算的争夺</p>
<h1 id="比特币知识（二）"><a href="#比特币知识（二）" class="headerlink" title="比特币知识（二）"></a>比特币知识（二）</h1><p><a href="http://blog.yuccn.net/archives/71.html" target="_blank" rel="noopener">http://blog.yuccn.net/archives/71.html</a></p>
<p>故事中，最初的物物交换就是原始人最初的交易方式，使用石头交易是物物交易的进阶。再到部落居民使用三叔和山娃的存条进行交易，就是典型的中心化系统模式了，类似今天的银行。再到记账模式，参与记账的居民，就是现实中比特币的矿机（参与记账的电脑节点），每个矿机会保存着一份完整的帐本。</p>
<p>矿机之间通过商定的协议使得所有矿机的帐本是一模一样的<br>一个去中性化的货币模式就这样形成了</p>
<h1 id="比特币知识（三）"><a href="#比特币知识（三）" class="headerlink" title="比特币知识（三）"></a>比特币知识（三）</h1><p><a href="http://blog.yuccn.net/archives/82.html" target="_blank" rel="noopener">http://blog.yuccn.net/archives/82.html</a><br>比特币总量为2100万，是固定数量的。</p>
<p>比特币最小单位是聪（satoshis），一个比特币 等于 一亿个聪，1BTC=10的8次方</p>
<p><img src="https://s1.ax1x.com/2018/05/14/CrUct0.png" alt></p>
<p>比特币总数计算代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!usr&#x2F;bin&#x2F;python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">startbtc&#x3D;50		#初始一个区块产生的比特币</span><br><span class="line">block&#x3D;210000	#每210000个区块产生后，比特币减半</span><br><span class="line"></span><br><span class="line">btc&#x3D;startbtc* 10**8	#最初一个区块产生的50个比特币，单位satoshis</span><br><span class="line">total&#x3D;0			#最终总的btc</span><br><span class="line">while btc&gt;0:</span><br><span class="line">	total&#x3D;total+block*btc</span><br><span class="line">	btc&#x3D;btc&#x2F;2</span><br><span class="line">total&#x3D;total&#x2F;(10**8)</span><br><span class="line">print u&quot;Total BTC: %d 个&quot;%total</span><br></pre></td></tr></table></figure>

<p>执行结果<br>python btctest.py<br>Total BTC: 20999999 个</p>
<h1 id="比特币知识（四）"><a href="#比特币知识（四）" class="headerlink" title="比特币知识（四）"></a>比特币知识（四）</h1><p><a href="http://blog.yuccn.net/archives/95.html" target="_blank" rel="noopener">http://blog.yuccn.net/archives/95.html</a><br>比特币特点：</p>
<p>1、去中心化： 货币由中心发行和管理（类似今天的中央银行）<br>2、匿名性，专属拥有： 比特币系统记账是匿名的， 比特币账号本质是一个地址，没有记录拥有者的任何信息<br>专属拥有性: 有比特币地址（密码学上的公钥），私密的密码（密码学上的私钥），才能真正拥有该账号且可以使用<br>3、世界范围内流通：直接转账，无手续费，汇率差等。</p>
<h1 id="比特币知识（五）"><a href="#比特币知识（五）" class="headerlink" title="比特币知识（五）"></a>比特币知识（五）</h1><p><a href="http://blog.yuccn.net/archives/209.html#comment-76" target="_blank" rel="noopener">http://blog.yuccn.net/archives/209.html#comment-76</a></p>
<p>矿机、挖矿什么、矿池<br>矿机： 不停挖矿的机器，也就是电脑<br>矿池：一堆矿机 (一起挖矿，平分一起挖到的矿)</p>
<p>比特币交易的数据是分布式存储记录的。</p>
<p>挖矿的本质类似之前的记账<br>把一段时间内的交易打包在一起（一个区块）<br>然后获得比特币</p>
<p>挖矿报酬–比特币来源：<br>（1）系统生成，每生成一个区块就会生成一定的比特币奖励给矿工（记账），生成的比特币会越来越少。<br>（2）交易手续费，比特币交易中，拿出一些费用作为手续费。</p>
<p>挖矿本质就是记账，把一对账目（即交易）打包在一起，就是一个区块。</p>
<p>区块里有很多交易条目<br>同时带有：<br>（1）hash<br>（2）时间戳<br>（3）索引号<br>（4）上一块数据的hash<br>（5）随机数等<br>（6）…<br><img src="https://s1.ax1x.com/2018/05/14/CrUbh6.md.png" alt></p>
<p>记账权-由工作量证明（Proof Of Work，简称POW）来决定</p>
<p>做一道数学题，谁先算出，打包权和奖励金就归谁（挖到矿了）</p>
<p>每个区块里有个信息记录摘要值hash以及随机数nonce (Number once)</p>
<p>计算过程：需要算出一个nonce,使得整个区块的hash值前面有n个0 (n称为计算难度)</p>
<p><img src="https://s1.ax1x.com/2018/05/14/CrUHtx.md.png" alt></p>
<p>例子，数据为hello china. 计算难度为3<br>使得 “hello china.nonce” 的哈希值格式为：<br>“000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx”，前面三个要求为0。</p>
<p>sha256(“hello china.0”) = “72442cbab482ac912ab04a4d735ca13afad5d47970649fd4683775cb6080cd4f”<br>sha256(“hello china.1”) = “25d64131521b3c83d27c3cae53ef79e573bc27e3658566c25c33bffe8ba588a7”<br>sha256(“hello china.2”) = “bc79953d627fc9de365ed26018d663bafdf8c6c02e236d11816f94eecb484b0f”<br>……<br>sha256(“hello china.2346”) = “000b6d006b4e31d9837f446dca65ebfb7246196cb00e6ee404cf243e73eef413”</p>
<p>nonce=2346时，满足了要求。如果n较大，这个求值计算量是非常庞大的。</p>
<p>区块链的不可修改性<br>后一个区块有前一个区块的hash, 所以要改变得改变全部。</p>
<p>计算获取随机数的时间，代码实现（示例）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#!usr&#x2F;bin&#x2F;python</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">import hashlib</span><br><span class="line">import time</span><br><span class="line">import sys </span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">#BTC包含的数据</span><br><span class="line">index</span><br><span class="line">previous_hash </span><br><span class="line">timestamp</span><br><span class="line">hash</span><br><span class="line">transaction </span><br><span class="line">nonce</span><br><span class="line"></span><br><span class="line">data&#x3D;index+previous_hash+timestamp+transaction+nonce  #对该数据进行sha256加密</span><br><span class="line"></span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">def get_hash(data):		#对data加密</span><br><span class="line">	result&#x3D;hashlib.sha256()</span><br><span class="line">	result.update(data)</span><br><span class="line">	return result.hexdigest()	#返回加密串</span><br><span class="line">	</span><br><span class="line">def get_nonce(hash,n):		#n表示计算难度,这里判断hash前n位是否为0</span><br><span class="line">	for i in range(0,n):</span><br><span class="line">		if hash[i]!&#x3D;&#39;0&#39;:	#hash值从0到n,如果有不为0的则返回False</span><br><span class="line">			return False</span><br><span class="line">	return True</span><br><span class="line">	</span><br><span class="line">def hash_calculate(index,previous_hash,timestamp,transaction,n):#n表示计算难度</span><br><span class="line">	hash&#x3D;&quot;&quot;		#初始化</span><br><span class="line">	nonce&#x3D;0		#初始随机数</span><br><span class="line">	while True:</span><br><span class="line">		data&#x3D;str(index)+previous_hash+timestamp+transaction+str(nonce)</span><br><span class="line">		hash&#x3D;get_hash(data)		#计算hash</span><br><span class="line">		if get_nonce(hash,n):	#获取hash值前n位为0</span><br><span class="line">			return hash,nonce	#计算成功返回hash值和随机数nonce </span><br><span class="line">		nonce&#x3D;nonce+1		</span><br><span class="line">	</span><br><span class="line">def blockchain(index,previous_hash,timestamp,transaction,hash,nonce):</span><br><span class="line">	print &quot;-----------------------------------------------------&quot;</span><br><span class="line">	print u&quot;第%s个区块信息:&quot; % str(index)</span><br><span class="line">	print u&quot;区块index: %s&quot; % str(index)</span><br><span class="line">	print u&quot;区块previous_hash: %s&quot; % previous_hash</span><br><span class="line">	print u&quot;区块timestamp: %s&quot; % timestamp</span><br><span class="line">	print u&quot;区块transaction: %s &quot; % transaction</span><br><span class="line">	print u&quot;区块hash: %s&quot; % hash</span><br><span class="line">	print u&quot;区块nonce: %d&quot; % nonce</span><br><span class="line">		</span><br><span class="line">if __name__&#x3D;&#x3D;&quot;__main__&quot;:</span><br><span class="line">	n&#x3D;int(sys.argv[1])		#传入计算难度</span><br><span class="line">	#print n</span><br><span class="line">	#data&#x3D;&quot;admin&quot;</span><br><span class="line">	#print get_hash(data)</span><br><span class="line">	#print get_nonce(get_hash(data),n)</span><br><span class="line">	block_transaction&#x3D;[&quot;test1&quot;,&quot;test2&quot;,&quot;test3&quot;,&quot;test4&quot;]		#区块交易数据(transaction)</span><br><span class="line">	#index&#x3D;0</span><br><span class="line">	previous_hash&#x3D;&quot;&quot;	#创世块，previous_hash为空</span><br><span class="line">	nowtime&#x3D;time.time()	#获取当前时间戳</span><br><span class="line">	for i in range(0,len(block_transaction)):</span><br><span class="line">		#获取指定格式的时间</span><br><span class="line">		timenow&#x3D;time.localtime(nowtime)	#获取当前时间，年月日时分秒格式</span><br><span class="line">		thetime&#x3D;time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,timenow) #指定时间格式</span><br><span class="line">		#print thetime</span><br><span class="line">		hash,nonce&#x3D;hash_calculate(i,previous_hash,thetime,block_transaction[i],n+i)#后面每个区块难度加1</span><br><span class="line">		#print hash</span><br><span class="line">		#print nonce</span><br><span class="line">		blockchain(i,previous_hash,thetime,block_transaction[i],hash,nonce)</span><br><span class="line">		print u&quot;计算nonce耗时:%d 毫秒&quot;% ((time.time()-nowtime)*1000)	#获取计算时间</span><br><span class="line">		print &quot;-----------------------------------------------------&quot;</span><br><span class="line">		previous_hash&#x3D;hash</span><br><span class="line">		nonce&#x3D;0</span><br></pre></td></tr></table></figure>
<p>执行结果<br><img src="https://s1.ax1x.com/2018/05/14/CrU6kq.md.png" alt></p>
<h1 id="比特币知识（六）"><a href="#比特币知识（六）" class="headerlink" title="比特币知识（六）"></a>比特币知识（六）</h1><p><a href="http://blog.yuccn.net/archives/316.html" target="_blank" rel="noopener">http://blog.yuccn.net/archives/316.html</a></p>
<p>从下载大文件说起<br>如文件只在一个服务器上存在，下载源有一个<br><img src="https://s1.ax1x.com/2018/05/15/CsZQRP.png" alt></p>
<p>缺点：<br>下载用户过多：服务器压力过大<br>下载异常断开：则需要重新下载<br>服务器异常关机：无法下载</p>
<p>多个资源节点下载大文件<br><img src="https://s1.ax1x.com/2018/05/15/CsZ3M8.png" alt></p>
<p>不同的节点下载各块的时候，涉及一个校验块是否正确的问题。<br>如何确保下载的每一块的数据是正确的（下载出错或者服务器伪造假数据）</p>
<p>解决校验问题，采用hash list<br><img src="https://s1.ax1x.com/2018/05/15/CsZ8sS.png" alt></p>
<p>hash list存在着不足，所以促使了Merkle Tree 结构的诞生。<br><img src="https://s1.ax1x.com/2018/05/15/CsZGqg.md.png" alt></p>
<p>hash list： 需要下载整个list才能校验<br>Mercle Tree: 只需下载其对应的分支就可以做校验，确保Root hash从可信机器下载。</p>
<p>前面提到，每个区块内的数据有previous hash, nonce,timestamp,hash和transaction<br>其实，在区块里是不包含transaction的<br>它包含的数据就是这个区块内的交易生成的一个Merkle Tree的那个Root hash 节点。<br><img src="https://s1.ax1x.com/2018/05/15/CsZtaj.md.png" alt></p>
<p>这样做的好处是可以仅下载区块头<br>不需要下载整个区块下的每一笔交易及其每一个区块（数据量很大），简化支付验证（SPV）</p>
<p>一个轻客户端希望确定一笔交易的状态：</p>
<p>（1）从网络上获取并保存最长链的所有区块头信息<br>（2）计算该交易的hash值（tx_hash）<br>（3）定位到包含该tx_hash所在的区块，验证其区块头是否包含在已知的最长链中。<br>（4）从区块中获取构建Merkle Tree所需的hash值<br>（5）根据这些hash值计算出Merkle Tree 的root hash<br>（6）若计算结果与区块头中的Merkle Tree 的root hash相等，则交易真实存在。</p>
<h1 id="比特币知识（七）"><a href="#比特币知识（七）" class="headerlink" title="比特币知识（七）"></a>比特币知识（七）</h1><p><a href="http://blog.yuccn.net/archives/459.html" target="_blank" rel="noopener">http://blog.yuccn.net/archives/459.html</a></p>
<p>矿机每成功生产一个区块，就会获得一定量的比特币<br>这些比特币:<br>（1）一部分来自交易的手续费<br>（2）另外一部分是按照算法共识生成的<br>比特币不是某个系统或者机构发行的！！！</p>
<p>以下是一个完整的区块信息，包含区块头和区块体。<br>区块体：矿机记录交易的的内容。<br><img src="https://s1.ax1x.com/2018/05/15/CsZNIs.md.png" alt></p>
<p>看实例<br>区块209999<br><a href="https://btc.com/00000000000000f3819164645360294b5dee7f2e846001ac9f41a70b7a9a3de1" target="_blank" rel="noopener">https://btc.com/00000000000000f3819164645360294b5dee7f2e846001ac9f41a70b7a9a3de1</a></p>
<p><img src="https://s1.ax1x.com/2018/05/15/CsZrsU.png" alt></p>
<p>跟别的交易不一样，该交易左边输出为coinbase<br>输出方：比特币系统（造币）<br>比特币系统：所有矿机连接起来组成一个网络，正在挖矿的矿机都是整个系统的一部分。</p>
<p>矿机挖矿：本质是在争夺记录交易，并且计算符合要求的hash。<br>除了第一条交易之外，其他的都是真真正正的交易。（A转了多少coin给B）</p>
<p>而第一条交易记录就是这样的一个记录了，它按照共识约定的算法，<br>自己写上一定数量比特币，并且把它写着归属自己的钱包地址。<br>可以这样理解，所有矿机在计算hash 前，都会写上第一条交易记录：<br>coinbase “转账”了n 个比特币给自己，<br>第二条开始记录的才是监听到的真正交易列表。只有在自己最先计算出合要求的hash，<br>并且把区块信息广播出去，达到一定数量的矿机确认了，这个区块才算有效，<br>这个时候，这个“转账”的比特币才真正属于自己的。</p>
<p>比特币如何发行的：矿机找到一个合法的区块的时候，自己给自己“发行”了比特币（即第一个交易）<br>这就是比特币系统发行比特币的过程。</p>
<h1 id="比特币知识（八）"><a href="#比特币知识（八）" class="headerlink" title="比特币知识（八）"></a>比特币知识（八）</h1><p><a href="http://blog.yuccn.net/archives/576.html" target="_blank" rel="noopener">http://blog.yuccn.net/archives/576.html</a></p>
<p>在比特币系统中，矿机在不断的挖矿—记账。<br>矿机集体挖矿特点：总体上挖矿 出区块的时间大致是均匀的，平均10分钟挖出一个区块。</p>
<p>比特币系统通过控制难度系数（hash前面有n个0，这个n值），来动态调整使得均匀区块的。</p>
<p>矿机集体挖矿，会达成一个共识：<br>每产生2016个区块，会统计这2016个区块的平均出块时间。<br>如果</p>
<p>平均时间&lt; 期望时间：矿机们会增大难度系数<br>平均时间&gt; 期望时间 : 矿机们会减小难度系数</p>
<p>动态调整难度系数！！！ 使出块平均值尽量接近10分钟。</p>
<p>比特币系统（矿机们）就是按照这样达成的共识算法<br>每产生2016个区块，就调整一次出块难度系数，使得总体上接近均匀出块。</p>
<p>2016*10=20160分钟=14天=2周</p>
<p>因此有比特币系统每两周进行一次难度系数调整。（其实是约等于2周进行一次难度系数调整）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.yi-diandian.com/2020/04/06/btc/" data-id="ck8nv1aja0001gkh57f654w8c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag">区块链</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%AF%94%E7%89%B9%E5%B8%81/" rel="tag">比特币</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-aquatone" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/06/aquatone/" class="article-date">
  <time datetime="2020-04-06T02:28:14.205Z" itemprop="datePublished">2020-04-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/">渗透测试</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/06/aquatone/">子域名扫描工具aquatone</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="工具地址"><a href="#工具地址" class="headerlink" title="工具地址"></a>工具地址</h1><p><a href="https://github.com/michenriksen/aquatone" target="_blank" rel="noopener">https://github.com/michenriksen/aquatone</a></p>
<p>参考freebuf上翻译的一篇文章</p>
<p><a href="http://www.freebuf.com/sectool/137806.html" target="_blank" rel="noopener">http://www.freebuf.com/sectool/137806.html</a></p>
<h1 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h1><p>系统：kali linux</p>
<h1 id="扫描子域名"><a href="#扫描子域名" class="headerlink" title="扫描子域名:"></a>扫描子域名:</h1><p>aquatone-discover -d baidu.com</p>
<h1 id="扫描端口"><a href="#扫描端口" class="headerlink" title="扫描端口:"></a>扫描端口:</h1><p>aquatone-scan -p huge -d baidu.com</p>
<p>其中:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**small:** 80, 443</span><br><span class="line">**medium:** 80, 443, 8000, 8080, 8443 (same as default)</span><br><span class="line">**large: **80, 81, 443, 591, 2082, 2095, 2096, 3000, 8000, 8001, 8008, 8080, 8083, 8443, 8834, 8888, 55672</span><br><span class="line">**huge: **80, 81, 300, 443, 591, 593, 832, 981, 1010, 1311, 2082, 2095, 2096, 2480, 3000, 3128, 3333, 4243, 4567, 4711, 4712, 4993, 5000, 5104, 5108, 5280, 5281, 5800, 6543, 7000, 7396, 7474, 8000, 8001, 8008, 8014, 8042, 8069, 8080, 8081, 8083, 8088, 8090, 8091, 8118, 8123, 8172, 8222, 8243, 8280, 8281, 8333, 8337, 8443, 8500, 8834, 8880, 8888, 8983, 9000, 9043, 9060, 9080, 9090, 9091, 9200, 9443, 9800, 9981, 11371, 12443, 16080, 18091, 18092, 20720, 55672</span><br></pre></td></tr></table></figure>
<p>效果还是很好的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.yi-diandian.com/2020/04/06/aquatone/" data-id="ck8nv1ajg0005gkh53z4ha6lp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/aquatone/" rel="tag">aquatone</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/" rel="tag">渗透测试</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-third" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/06/third/" class="article-date">
  <time datetime="2020-04-06T02:28:13.787Z" itemprop="datePublished">2020-04-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/">信息安全</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/06/third/">信息安全领域</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>总结得蛮好蛮全面，供参考。</p>
<p><img src="https://s1.ax1x.com/2018/02/27/9BCsd1.png" alt></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.yi-diandian.com/2020/04/06/third/" data-id="ck8nv1akh001ygkh52zeo3wo5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/" rel="tag">信息安全</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CTF/">CTF</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Go/">Go</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/">信息安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E7%A1%80/">基础</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/">日志分析</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/">渗透测试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/" rel="tag">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DASP/" rel="tag">DASP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EOS/" rel="tag">EOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Github/" rel="tag">Github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go/" rel="tag">Go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hawkeye/" rel="tag">Hawkeye</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Proxifier/" rel="tag">Proxifier</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSRF/" rel="tag">SSRF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TOP10/" rel="tag">TOP10</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/aquatone/" rel="tag">aquatone</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ew/" rel="tag">ew</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/" rel="tag">github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/log/" rel="tag">log</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reGeorg/" rel="tag">reGeorg</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sock5/" rel="tag">sock5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/urllib2/" rel="tag">urllib2</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%90%86/" rel="tag">代理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/" rel="tag">信息安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E7%BD%91/" rel="tag">内网</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag">区块链</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%9A%E5%AE%A2/" rel="tag">博客</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%90%E5%9F%9F%E5%90%8D/" rel="tag">子域名</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E5%85%A8/" rel="tag">安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AF%86%E7%A0%81/" rel="tag">密码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%83%8A%E8%9B%B0/" rel="tag">惊蛰</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/" rel="tag">日志分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/" rel="tag">智能合约</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/" rel="tag">暴力破解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AF%94%E7%89%B9%E5%B8%81/" rel="tag">比特币</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/" rel="tag">渗透测试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BC%8F%E6%B4%9E/" rel="tag">漏洞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%88%AC%E8%99%AB/" rel="tag">爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/" rel="tag">端口扫描</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B/" rel="tag">编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/" rel="tag">远程代码执行漏洞</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CTF/" style="font-size: 13.33px;">CTF</a> <a href="/tags/DASP/" style="font-size: 10px;">DASP</a> <a href="/tags/EOS/" style="font-size: 10px;">EOS</a> <a href="/tags/Github/" style="font-size: 10px;">Github</a> <a href="/tags/Go/" style="font-size: 16.67px;">Go</a> <a href="/tags/Hawkeye/" style="font-size: 10px;">Hawkeye</a> <a href="/tags/Proxifier/" style="font-size: 10px;">Proxifier</a> <a href="/tags/Python/" style="font-size: 16.67px;">Python</a> <a href="/tags/SSRF/" style="font-size: 10px;">SSRF</a> <a href="/tags/TOP10/" style="font-size: 10px;">TOP10</a> <a href="/tags/aquatone/" style="font-size: 10px;">aquatone</a> <a href="/tags/ew/" style="font-size: 10px;">ew</a> <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/log/" style="font-size: 10px;">log</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/reGeorg/" style="font-size: 10px;">reGeorg</a> <a href="/tags/sock5/" style="font-size: 10px;">sock5</a> <a href="/tags/urllib2/" style="font-size: 10px;">urllib2</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 13.33px;">代理</a> <a href="/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/" style="font-size: 13.33px;">信息安全</a> <a href="/tags/%E5%86%85%E7%BD%91/" style="font-size: 10px;">内网</a> <a href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" style="font-size: 16.67px;">区块链</a> <a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 10px;">博客</a> <a href="/tags/%E5%AD%90%E5%9F%9F%E5%90%8D/" style="font-size: 10px;">子域名</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 10px;">安全</a> <a href="/tags/%E5%AF%86%E7%A0%81/" style="font-size: 10px;">密码</a> <a href="/tags/%E6%83%8A%E8%9B%B0/" style="font-size: 10px;">惊蛰</a> <a href="/tags/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/" style="font-size: 10px;">日志分析</a> <a href="/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/" style="font-size: 13.33px;">智能合约</a> <a href="/tags/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/" style="font-size: 10px;">暴力破解</a> <a href="/tags/%E6%AF%94%E7%89%B9%E5%B8%81/" style="font-size: 10px;">比特币</a> <a href="/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/" style="font-size: 20px;">渗透测试</a> <a href="/tags/%E6%BC%8F%E6%B4%9E/" style="font-size: 10px;">漏洞</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 10px;">爬虫</a> <a href="/tags/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/" style="font-size: 10px;">端口扫描</a> <a href="/tags/%E7%BC%96%E7%A8%8B/" style="font-size: 16.67px;">编程</a> <a href="/tags/%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/" style="font-size: 10px;">远程代码执行漏洞</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/06/ew/">ew使用教程</a>
          </li>
        
          <li>
            <a href="/2020/04/06/dasp/">DASP智能合约Top10漏洞</a>
          </li>
        
          <li>
            <a href="/2020/04/06/ctfwriteup2/">WriteUp-Web暴力破解</a>
          </li>
        
          <li>
            <a href="/2020/04/06/ctfwriteup/">WriteUp-源代码审计</a>
          </li>
        
          <li>
            <a href="/2020/04/06/btc4/">EOS节点远程代码执行漏洞</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Jean<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>